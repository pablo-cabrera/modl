<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>lib&#x2F;modl.js - modl</title>
    <link rel="stylesheet" href="http:&#x2F;&#x2F;yui.yahooapis.com&#x2F;3.8.0&#x2F;build&#x2F;cssgrids&#x2F;cssgrids-min.css">
    <link rel="stylesheet" href="..&#x2F;assets/vendor/prettify/prettify-min.css">
    <link rel="stylesheet" href="..&#x2F;assets/css/main.css" id="site_styles">
    <link rel="shortcut icon" type="image/png" href="..&#x2F;assets/favicon.png">
    <script src="http:&#x2F;&#x2F;yui.yahooapis.com&#x2F;combo?3.8.0&#x2F;build&#x2F;yui&#x2F;yui-min.js"></script>
</head>
<body class="yui3-skin-sam">

<div id="doc">
    <div id="hd" class="yui3-g header">
        <div class="yui3-u-3-4">
            
                <h1><img src="..&#x2F;assets/css/logo.png" title="modl"></h1>
            
        </div>
        <div class="yui3-u-1-4 version">
            <em>API Docs for: 0.0.1</em>
        </div>
    </div>
    <div id="bd" class="yui3-g">

        <div class="yui3-u-1-4">
            <div id="docs-sidebar" class="sidebar apidocs">
                <div id="api-list">
    <h2 class="off-left">APIs</h2>
    <div id="api-tabview" class="tabview">
        <ul class="tabs">
            <li><a href="#api-classes">Classes</a></li>
            <li><a href="#api-modules">Modules</a></li>
        </ul>

        <div id="api-tabview-filter">
            <input type="search" id="api-filter" placeholder="Type to filter APIs">
        </div>

        <div id="api-tabview-panel">
            <ul id="api-classes" class="apis classes">
            
                <li><a href="..&#x2F;classes/Asset.html">Asset</a></li>
            
<<<<<<< HEAD
=======
                <li><a href="..&#x2F;classes/Future.html">Future</a></li>
            
                <li><a href="..&#x2F;classes/Loader.html">Loader</a></li>
            
>>>>>>> gh-pages
                <li><a href="..&#x2F;classes/modl.html">modl</a></li>
            
                <li><a href="..&#x2F;classes/Module.html">Module</a></li>
            
                <li><a href="..&#x2F;classes/Ready.html">Ready</a></li>
            
            </ul>

            <ul id="api-modules" class="apis modules">
            
            </ul>
        </div>
    </div>
</div>

            </div>
        </div>
        <div class="yui3-u-3-4">
                <div id="api-options">
        Show:
        <label for="api-show-inherited">
            <input type="checkbox" id="api-show-inherited" checked>
            Inherited
        </label>

        <label for="api-show-protected">
            <input type="checkbox" id="api-show-protected">
            Protected
        </label>

        <label for="api-show-private">
            <input type="checkbox" id="api-show-private">
            Private
        </label>
        <label for="api-show-deprecated">
            <input type="checkbox" id="api-show-deprecated">
            Deprecated
        </label>

    </div>


            <div class="apidocs">
                <div id="docs-main">
                    <div class="content">
                        <h1 class="file-heading">File: lib&#x2F;modl.js</h1>

<div class="file">
    <pre class="code prettyprint linenums">
(function(global) {
    &quot;use strict&quot;;

    var
        &#x2F;**
         * The defaults asset for a modl
         *
         * @property MODL_ASSET
         * @for modl
         * @type string
         * @static
         * @private
         * @final
         *&#x2F;
        MODL_ASSET = &quot;&#x2F;modl&quot;,

        &#x2F;**
         * The regex to parse a resource
         *
         * @property RESOURCE_RE
         * @for modl
         * @type RegEx
         * @static
         * @private
         * @final
         *&#x2F;
        RESOURCE_RE = &#x2F;([^\&#x2F;]*)(\&#x2F;.+)?&#x2F;,

        &#x2F;**
         * The regex to get the alias from the resource name
         *
         * @property ALIAS_RE
         * @for modl
         * @type RegEx
         * @static
         * @private
         * @final
         *&#x2F;
        ALIAS_RE = &#x2F;(.*\&#x2F;)?([^\&#x2F;]+)$&#x2F;,

        &#x2F;**
         * The regex used to remove double (or more) slashes from a path
         *
         * @property PATH_RE
         * @for modl
         * @type RegEx
         * @static
         * @private
         * @final
         *&#x2F;
        PATH_RE = &#x2F;\&#x2F;{2,}&#x2F;g,

        &#x2F;**
         * A reference to the undefined value used internally
         *
         * @property undef
         * @for modl
         * @type undefined
         * @static
         * @private
         * @final
         *&#x2F;
        undef = void 0,

        &#x2F;**
         * Flag that indicates if we are running under nodejs environment
         *
         * @property node
         * @type boolean
         * @static
         * @private
         * @final
         *&#x2F;
        node = typeof exports !== &quot;undefined&quot; &amp;&amp; global.exports !== exports,

        &#x2F;**
         * Array containing all
         *
         * @property node
         * @for modl
         * @type boolean
         * @static
         * @private
         * @final
         *&#x2F;
        validSettings = [&quot;debug&quot;, &quot;root&quot;],

        &#x2F;**
         * Contains current settings for the modl loader
         *
         * @property settings
         * @for modl
         * @type Object
         * @static
         * @private
         *&#x2F;
        settings = null,

        &#x2F;**
         * Points to the current module being loaded
         *
         * @property current
         * @for modl
         * @type Module
         * @static
         * @private
         *&#x2F;
        current,

        &#x2F;**
         * Points to the asset being loaded at the moment
         *
         * @property loadingAsset
         * @for modl
         * @type Asset
         * @static
         * @private
         *&#x2F;
        loadingAsset,

        &#x2F;**
         * Helper function to log messages when the debug flag is enabled
         *
         * @method log
         * @for modl
         * @param args* {mixed} Arguments to be logged
         * @private
         * @static
         *&#x2F;
        log = function() {
            var args, d;
            if (settings.debug &amp;&amp; console &amp;&amp; typeof console.log === &quot;function&quot;) {
                args = Array.prototype.slice.call(arguments);
                args.unshift(ts());
                console.log.apply(this, args);
            }
        },

        &#x2F;**
         * Returns a formatted current timestamp with &lt;code&gt;hh:mm:ss&lt;&#x2F;code&gt; to be used for logging purposes
         *
         * @method ts
         * @for modl
         * @private
         * @static
         * @return {string} The formatted timestamp
         *&#x2F;
        ts = function() {
            var d = new Date(),
                z = function(n) { return n &lt; 10 ? &quot;0&quot; + n : String(n); };

            return &quot;[&quot; + z(d.getHours()) + &quot;:&quot; + z(d.getMinutes()) + &quot;:&quot; + z(d.getSeconds()) + &quot;]&quot;;
        },

        &#x2F;**
         * Short for Object.prototype.hasOwnProperty
         *
         * @method hop
         * @for modl
         * @private
         * @static
         * @param {object} o Object to check its property
         * @param {string} p Property name
<<<<<<< HEAD
         * @return {boolean} Wether a property exists within the object or not
=======
         * @return {boolean} whether a property exists within the object or not
>>>>>>> gh-pages
         *&#x2F;
        hop = function(o, p) {
            return Object.prototype.hasOwnProperty.call(o, p);
        },

        &#x2F;**
         * Merges all properties from &lt;b&gt;b&lt;&#x2F;b&gt; into &lt;b&gt;a&lt;&#x2F;b&gt;. Optionally it
         * can be passes a property whitelist
         *
         * @method merge
         * @for modl
         * @private
         * @static
         * @param {object} a The target object
         * @param {object} b The source object
         * @param {array} [list] Properties whitelist
         *&#x2F;
        merge = function(a, b, list) {
            if (list) {
                forEach(list, function(p) {
                    if (hop(b, p)) {
                        a[p] = b[p];
                    }
                });
            } else {
                forEach(b, function(v, p) {
                    a[p] = v;
                });
            }
        },

        &#x2F;**
         * Iterates over an object&#x27;s properties or an array&#x27;s values calling the
         * &lt;b&gt;f&lt;&#x2F;b&gt; callback function each time passing the value as it&#x27;s first
         * argument and the index or property name as it&#x27;s second argument.
         *
         * @method forEach
         * @for modl
         * @private
         * @static
         * @param {array|object} a The array or object to be iterated
         * @param {function} f The callback function for each iteration
         *&#x2F;
        forEach = function(a, f) {
            indexOf(a, function(v, i) {
                f(v, i);
                return false;
            });
        },

        &#x2F;**
         * Iterates over an object&#x27;s properties or an array&#x27;s values calling the
         * &lt;b&gt;f&lt;&#x2F;b&gt; callback function each time passing the value as it&#x27;s first
         * argument and the index or property name as it&#x27;s second argument. The
         * callback function must return either &lt;code&gt;true&lt;&#x2F;code&gt; or
         * &lt;code&gt;false&lt;&#x2F;code&gt;. If for a given property or index the function
         * returns &lt;code&gt;true&lt;&#x2F;code&gt; then the indexOf function will return the
         * current property name or index.
         *
         * @method indexOf
         * @for modl
         * @private
         * @static
         * @param {array|object} a The array or object to be iterated
         * @param {function} f The callback function for each iteration
         *&#x2F;
        indexOf = function(a, f) {
            var i, l;

            if (Object.prototype.toString.call(a) === &quot;[object Array]&quot;) {
                for (i = 0, l = a.length; i &lt; l; i += 1) {
                    if (f(a[i], i)) {
                        return i;
                    }
                }
            } else {
                for (i in a) {
                    if (hop(a, i)) {
                        if (f(a[i], i)) {
                            return i;
                        }
                    }
                }
            }
        },

        &#x2F;**
         * A type creator helper. This function will construct a pseudo-class
         * using the &lt;b&gt;specs&lt;&#x2F;b&gt; object for it&#x27;s definition.
         *
         * The &lt;b&gt;specs&lt;&#x2F;b&gt; object must have a &lt;b&gt;constr&lt;&#x2F;b&gt; object for it
         * will be used as the constructor function. Optionally, it could have a
         * &lt;b&gt;proto&lt;&#x2F;b&gt; object that may contain properties which will be
         * augmented to the constructor&#x27;s prototype.
         *
         * The constructor function will have a &lt;b&gt;descend&lt;&#x2F;b&gt; method that can
         * be called to create another type using the same constraints as the
         * &lt;b&gt;type&lt;&#x2F;b&gt; method, plus the child constructor will have an
         * &lt;b&gt;ancestor&lt;&#x2F;b&gt; property which will reference the parent&#x27;s
         * prototype.
         *
         * @method type
         * @for modl
         * @private
         * @static
         * @param {object} specs The specs object
         * @param {function} specs.constr The constructor function
         * @param {object} [specs.proto] Object containing properties to augment the constructor&#x27;s prototype with
         * @return {function} The new created type
         *&#x2F;
        type = function(specs) {
            var constr = specs.constr || function() {};
            if (specs.proto) {
                merge(constr.prototype, specs.proto);
            }

            constr.descend = function(specs) {
                var child = specs.constr || function() {},
                    F = function() {};

                F.prototype = constr.prototype;
                child.prototype = new F();
                child.prototype.constructor = child;
                child.ancestor = constr.prototype;

                if (specs.proto) {
                    merge(child.prototype, specs.proto);
                }

                return child;
            };

            return constr;
        },

        &#x2F;**
         * Parses a require struct into a resource
         *
         * @method parseResource
         * @for modl
         * @static
         * @private
         * @param {object} require The require struct
         * @return {object} The parsed resource
         *&#x2F;
        parseResource = function(require) {
            var matches = require.resource.match(RESOURCE_RE),
                alias = require.alias,
                module = matches[1],
                asset = matches[2],
                aliasRe;

            if (!alias) {
                if (module) {
                    if (asset) {
                        alias = asset.replace(ALIAS_RE, &quot;$2&quot;);
                    } else {
                        alias = module;
                        asset = MODL_ASSET;
                    }
                } else {
                    alias = asset.replace(ALIAS_RE, &quot;$2&quot;);
                }
            }

            if (!asset) {
                asset = MODL_ASSET;
            }

            return {
                module : matches[1],
                asset : asset,
                alias : alias
            };
        },

        &#x2F;**
         * Loads a given script.
         *
         * @method loadScript
         * @for modl
         * @static
         * @private
         * @param {string} src The script&#x27;s src
         *&#x2F;
        loadScript = (function() {
            return node ?
                function(src) {
                    delete require.cache[src];
                    require(src);
                } :
                function(src) {
                    var s = document.createElement(&quot;script&quot;),
                        d = document.documentElement;
                    s.src = src;
                    d.insertBefore(s, d.firstChild);
                };
        }()),

        &#x2F;**
         * The Ready class provides the functionality of scheduling callbacks
         * for when a given Ready instance is marked as ready
         *
         * @class Ready
         * @constructor
         * @private
         *&#x2F;
        Ready = type({
            constr : function() {
                merge(this, {
                    &#x2F;**
<<<<<<< HEAD
                     * Indicates wether the instance is ready or not
=======
                     * Indicates whether the instance is ready or not
>>>>>>> gh-pages
                     *
                     * @property _readyStatus
                     * @for Ready
                     * @private
                     * @type {boolean}
                     *&#x2F;
                    _readyStatus : false,

                    &#x2F;**
                     * Callback functions are stored within this guy
                     *
                     * @property _callbacks
                     * @for Ready
                     * @private
                     * @type {array}
                     *&#x2F;
                    _callbacks : []
                });
            },

            proto : {
                &#x2F;**
                 * Schedules an &lt;b&gt;f&lt;&#x2F;b&gt; callback to be executed once the
                 * instance is marked as &lt;b&gt;ready&lt;&#x2F;b&gt;
                 *
                 * @method _whenReady
                 * @for Ready
                 * @private
                 * @param {function} f The callback function to be scheduled
                 *&#x2F;
                _whenReady : function(f) {
                    if (this._readyStatus) {
                        f();
                    } else {
                        this._callbacks.push(f);
                    }
                },

                &#x2F;**
                 * Marks the instance as &lt;b&gt;ready&lt;&#x2F;b&gt; and runs all it&#x27;s callbacks
                 *
                 * @method _ready
                 * @for Ready
                 * @private
                 *&#x2F;
                _ready : function() {
                    this._readyStatus = true;
                    forEach(this._callbacks, function(f) { f(); });
                }
            }
        }),

        &#x2F;**
         * The Module class represents a module within the modl tree. It can
         * load other &lt;b&gt;modules&lt;&#x2F;b&gt;(dependencies contained within
         * &lt;code&gt;node_modules&lt;&#x2F;code&gt; directory) and &lt;b&gt;assets&lt;&#x2F;b&gt; (files
         * referenced within a module).
         *
         * @class Module
         * @extends Ready
         * @constructor
         * @private
         * @param {string} name The module&#x27;s name
         * @param {string} path The module&#x27;s path
         *&#x2F;
        Module = Ready.descend({
            constr : function(name, path) {

                merge(this, {

                    &#x2F;**
                     * It&#x27;s name
                     *
                     * @property _name
                     * @for Module
                     * @private
                     * @type {string}
                     *&#x2F;
                    _name : name,

                    &#x2F;**
                     * It&#x27;s path
                     *
                     * @property _path
                     * @for Module
                     * @private
                     * @type {string}
                     *&#x2F;
                    _path : path,

                    &#x2F;**
                     * It&#x27;s inner modules. This will contain the references for
                     * the children modules currently loaded for this module.
                     *
                     * @property _modules
                     * @for Module
                     * @private
                     * @type {object}
                     *&#x2F;
                    _modules : {},

                    &#x2F;**
                     * It&#x27;s assets. This will contain the references for all
                     * assets currently loaded within this module.
                     *
                     * @property _assets
                     * @for Module
                     * @private
                     * @type {object}
                     *&#x2F;
                    _assets : {}

                });

                Ready.call(this);
                log(&quot;module created: &quot;, this);
                this.initialize();
            },

            proto : {

                &#x2F;**
                 * Initializes the module loading its &lt;code&gt;&#x2F;modl&lt;&#x2F;code&gt; asset
                 *
                 * @method initialize
                 * @for Module
                 *&#x2F;
                initialize : function() {
                    var that = this;

                    if (this._name !== &quot;&quot;) {
                        this.asset(&quot;&#x2F;modl&quot;).
                        when(function(err, asset) { that._ready(); });
                    } else {
                        this._ready();
                    }
                },

                &#x2F;**
                 * Loads an asset within the module.
                 *
                 * @method asset
                 * @for Module
                 * @param {string} name The asset&#x27;s name
                 * @return {Future} The future representing when the asset will
                 *         be loaded
                 *&#x2F;
                asset : function(name) {
                    var future = new Future(),
                        asset;

                    if (name in this._assets) {
                        log(&quot;old&quot;);
                        asset = this._assets[name];
                    } else {
                        log(&quot;new&quot;);
                        asset = new Asset(name, this._path);
                        this._assets[name] = asset;
                    }

                    asset._whenReady(function() {
                        future.fulfill(null, asset._loader._modl.exports);
                    });

                    return future;
                },

                &#x2F;**
<<<<<<< HEAD
                 * Loads child module within the module &lt;i&gt;(yo dawn!)&lt;&#x2F;i&gt;.
=======
                 * Loads child module within the module &lt;i&gt;(Yo dawg! I heard you like modules...)&lt;&#x2F;i&gt;.
>>>>>>> gh-pages
                 *
                 * @method module
                 * @for Module
                 * @param {string} name The module&#x27;s name
                 * @return {Future} The future representing when the module will
                 *         be loaded
                 *&#x2F;
                module : function(name) {
                    var future = new Future(),
                        module,
                        that = this;

                    if (name in this._modules) {
                        module = this._modules[name];
                    } else {
                        module = new Module(name, this._path + &quot;&#x2F;node_modules&#x2F;&quot; + name);
                        this._modules[name] = module;
                    }

                    current = module;

                    module._whenReady(function() {
                        current = that;
                        future.fulfill(null, module);
                    });

                    return future;
                }
            }
        }),

        &#x2F;**
         * The Asset class represents an script file being loaded within a
         * module.
         *
         * @class Asset
         * @extends Ready
         * @constructor
         * @private
         * @param {string} name It&#x27;s name
         * @param {string} path It&#x27;s path
         *&#x2F;
        Asset = Ready.descend({
            constr : function(name, path) {
                merge(this, {

                    &#x2F;**
                     * The asset&#x27;s name
                     *
                     * @property _name
                     * @for Asset
                     * @private
                     * @type {string}
                     *&#x2F;
                    _name : name,

                    &#x2F;**
                     * The asset&#x27;s script path
                     *
                     * @property _script
                     * @for Asset
                     * @private
                     * @type {string}
                     *&#x2F;
                    _script : (path + &quot;&#x2F;lib&quot; + name + &quot;.js&quot;).replace(PATH_RE, &quot;&#x2F;&quot;)
                });

                Ready.call(this);
                log(&quot;asset created: &quot;, this);
                this._load();
            },

            proto : {

                &#x2F;**
                 * Actually fires the asset loading
                 *
                 * @method _load
                 * @for Asset
                 * @private
                 *&#x2F;
                _load : function() {
                    loadingAsset = this;
                    loadScript(this._script);
                }
            }
        }),

<<<<<<< HEAD
        Future = type({
            proto: {
=======
        &#x2F;**
         * Represents a future promise
         *
         * @class Future
         * @constructor
         * @private
         *&#x2F;
        Future = type({
            constr : function() {
                merge(this, {
                    &#x2F;**
                     * Holds the sent error
                     *
                     * @property _err
                     * @for Future
                     * @private
                     * @type {mixed}
                     *&#x2F;
                    _err : undef,

                    &#x2F;**
                     * Holds the sent data
                     *
                     * @property _data
                     * @for Future
                     * @private
                     * @type {mixed}
                     *&#x2F;
                    _data : undef,

                    &#x2F;**
                     * Indicates whether the promise has been fulfilled
                     *
                     * @property _fulfilled
                     * @for Future
                     * @private
                     * @type {boolean}
                     *&#x2F;
                    _fulfilled : false,


                    &#x2F;**
                     * Holds the callback to be executed whenever the promise is fulfilled
                     *
                     * @property _when
                     * @for Future
                     * @private
                     * @type {function}
                     *&#x2F;
                    _when : undef
                });
            },
            proto: {

                &#x2F;**
                 * Fulfills the promise
                 *
                 * @method fulfill
                 * @for Future
                 * @param {mixed} [err] The error to be sent
                 * @param {mixed} [data] The data to be sent
                 *&#x2F;
>>>>>>> gh-pages
                fulfill : function(err, data) {
                    this._err = err;
                    this._data = data;

                    if (this._fulfilled) {
                        throw new Error(&quot;Future already fulfilled&quot;);
                    }

                    this._fulfilled = true;
                    if (this._when) {
                        this._when.call(null, err, data);
                    }
                },

<<<<<<< HEAD
=======
                &#x2F;**
                 * Register the callback if the promise is to be fulfilled,
                 * otherwise just runs it passing along the error&#x2F;data
                 * associated with the future
                 *
                 * @method when
                 * @for Future
                 * @param {function} f The callback function
                 *&#x2F;
>>>>>>> gh-pages
                when : function(f) {
                    if (this._fulfilled) {
                        f(this._err, this._data);
                    } else {
                        this._when = f;
                    }
                }
            }
        }),

<<<<<<< HEAD
        Loader = Ready.descend({
            constr : function() {
                merge(this, {
                    _requires : [],
=======
        &#x2F;**
         * The loader class responsible for loading the various dependencies between modules and assets
         *
         * @class Loader
         * @extends Ready
         * @constructor
         * @private
         *&#x2F;
        Loader = Ready.descend({
            constr : function() {
                merge(this, {
                    &#x2F;**
                     * The requires collection containing the various required
                     * data
                     *
                     * @property _requires
                     * @for Loader
                     * @private
                     * @type {array}
                     *&#x2F;
                    _requires : [],

                    &#x2F;**
                     * The modl instance to be passed along to the exports
                     * callback function when called
                     *
                     * @property _modl
                     * @for Loader
                     * @private
                     * @type {object}
                     *&#x2F;
>>>>>>> gh-pages
                    _modl : {
                        imports : {},
                        exports : {}
                    },
<<<<<<< HEAD
=======

                    &#x2F;**
                     * The callback function to be executed when all the
                     * requires are ready
                     *
                     * @property _payload
                     * @for Loader
                     * @private
                     * @type {function}
                     *&#x2F;
>>>>>>> gh-pages
                    _payload : function() {}
                });

                Ready.call(this);

                log(&quot;loader created: &quot;, this);
            },

            proto : {
<<<<<<< HEAD
=======

                &#x2F;**
                 * Requires an asset from it. The &lt;b&gt;resource&lt;&#x2F;b&gt; string may
                 * have the following formats:
                 *
                 *  - &lt;code&gt;&quot;&#x2F;path&#x2F;to&#x2F;asset&lt;&#x2F;code&gt;: in this case the asset
                 * within the current module will be loaded
                 *
                 *  - &lt;code&gt;&quot;module&quot;&lt;&#x2F;code&gt;: in this case the &quot;module&quot; within
                 * &lt;code&gt;node_modules&lt;&#x2F;code&gt; folder will be required, and
                 * afterwards the &lt;code&gt;&#x2F;modl&lt;&#x2F;code&gt; asset within the module
                 * will be loaded.
                 *
                 *  - &lt;code&gt;&quot;module&#x2F;path&#x2F;to&#x2F;asset&quot;&lt;&#x2F;code&gt;: in this case the
                 * &quot;module&quot; within &lt;code&gt;node_modules&lt;&#x2F;code&gt; folder will be
                 * required, and afterwards the indicated asset within the
                 * module will be loaded.
                 *
                 * Optionally an &lt;b&gt;alias&lt;&#x2F;b&gt; property may be passed to name
                 * the required asset within the &lt;b&gt;imports&lt;&#x2F;b&gt; object. If
                 * ommited, the alias will be automatically generated based the
                 * &lt;b&gt;resource&lt;&#x2F;b&gt; value.
                 *
                 * @param {string} resource A given resource to be required
                 * @param {string} [alias] An optional alias which to be named
                 *              within the &lt;b&gt;imports&lt;&#x2F;b&gt; object.
                 * @method require
                 * @for Loader
                 * @chainable
                 * @return {Loader} The loader instance
                 *&#x2F;
>>>>>>> gh-pages
                require : function(resource, alias) {
                    this._requires.push({resource : resource, alias : alias});
                    return this;
                },

<<<<<<< HEAD
=======
                &#x2F;**
                 * Schedules a given &lt;b&gt;payload&lt;&#x2F;b&gt;
                 * function export the &lt;i&gt;asset&lt;&#x2F;i&gt;. The &lt;b&gt;payload&lt;&#x2F;b&gt; will only
                 * run when all the requires are loaded and ready for prime time.
                 *
                 * When called, the &lt;b&gt;payload&lt;&#x2F;b&gt; function will receive the
                 * &lt;b&gt;module&lt;&#x2F;b&gt; struct as its first argument and as second
                 * argument, the &lt;b&gt;imports&lt;&#x2F;b&gt; object containing all required
                 * resources within will be passed.
                 *
                 * The &lt;b&gt;module&lt;&#x2F;b&gt; object will have an &lt;code&gt;exports&lt;&#x2F;code&gt;
                 * property which will be published for this asset. This property
                 * can be overwritten with any value this asset may want to publish (&lt;i&gt;a
                 * la&lt;&#x2F;i&gt; nodejs module system).
                 *
                 * The &lt;b&gt;module&lt;&#x2F;b&gt; object will also have an &lt;code&gt;imports&lt;&#x2F;code&gt;
                 * object containing all required resources which will be also
                 * passed as a second argument to the &lt;b&gt;payload&lt;&#x2F;b&gt; function
                 *
                 * @method exports
                 * @for Loader
                 * @param {function} payload The payload function
                 *&#x2F;
>>>>>>> gh-pages
                exports : function(payload) {
                    if (loadingAsset) {
                        this._attachAsset(loadingAsset);
                        loadingAsset = undef;
                    }
                    this._payload = payload;
                    this._dispatch();
                },

<<<<<<< HEAD
=======
                &#x2F;**
                 * Attach a given asset to this Loader. When the loader is
                 * ready, the asset will also be market as ready
                 *
                 * @method _attachAsset
                 * @for Loader
                 * @private
                 * @param {Asset} asset The asset to be attached
                 *&#x2F;
>>>>>>> gh-pages
                _attachAsset : function(asset) {
                    asset._loader = this;
                    this._whenReady(function() { asset._ready(); });
                },

<<<<<<< HEAD
                _dispatch : function() {
                    var that = this;
=======
                &#x2F;**
                 * Dispatches the loader processing. It will start loading all
                 * its requires and finally will run the payload function.
                 *
                 * @method _dispatch
                 * @for Loader
                 * @private
                 *&#x2F;
                _dispatch : function() {
                    var that = this,
                        aliases = {};

                    forEach(this._requires, function(r) {
                        r.details = parseResource(r);

                        if (hop(aliases, r.details.alias)) {
                            throw new Error(&quot;Alias clash: &quot; + r.details.alias);
                        }

                        aliases[r.details.alias] = undef;
                    });

>>>>>>> gh-pages
                    setTimeout(function() {
                        that._loadRequires().
                        when(function() {
                            that._payload.call(null, that._modl, that._modl.imports);
                            that._ready();
                        });
                    });
                },

<<<<<<< HEAD
=======
                &#x2F;**
                 * Loads all requires for the loader.
                 *
                 * @method _loadRequires
                 * @for Loader
                 * @private
                 * @return {Future} A promise for when all the requires are ready.
                 *&#x2F;
>>>>>>> gh-pages
                _loadRequires : function() {
                    var future = new Future(),
                        that = this,
                        requires = this._requires.slice(),

                        load = function(require) {
                            if (!require) {
                                log(&quot;done loading requires, moving on&quot;);
                                return future.fulfill();
                            }

                            that._loadRequire(require).
                            when(function() { load(requires.shift()); });
                        };

                    log(&quot;loading requires&quot;);

                    load(requires.shift());
                    return future;
                },

<<<<<<< HEAD
                _loadRequire : function(require) {
                    var
                        resource,
                        module,
                        asset,
                        future = new Future(),
                        that = this,

                        when = function(err, asset) {
                            log(&quot;require loaded: &quot;, require);
                            that._modl.imports[resource.alias] = asset;
=======
                &#x2F;**
                 * Loads a given requicre
                 *
                 * @param {object} require The require struct containing all its details
                 * @return {Future} The promise for when the require is done
                 *&#x2F;
                _loadRequire : function(require) {
                    var
                        details = require.details,
                        module = details.module,
                        asset = details.asset,
                        alias = details.alias,
                        future = new Future(),
                        that = this,

                        when = function(err, assetInstance) {
                            log(&quot;require loaded: &quot;, require);
                            that._modl.imports[alias] = assetInstance;
>>>>>>> gh-pages
                            future.fulfill();
                        };

                    log(&quot;loading require: &quot;, require);

<<<<<<< HEAD
                    resource = parseResource(require);
                    module = resource.module;
                    asset = resource.asset;

=======
>>>>>>> gh-pages
                    if (module) {
                        current.module(module).
                        when(function(err, module) {
                            module.asset(asset).
                            when(when);
                        });
                    } else {
                        current.asset(asset).
                        when(when);
                    }

                    return future;
                }
            }
        }),

        &#x2F;**
         * The modl loader
         *
         * @class modl
         * @static
         *&#x2F;
        modl = {

            &#x2F;**
             * Creates a &lt;b&gt;Loader&lt;&#x2F;b&gt; and requires an asset from it. The
             * &lt;b&gt;resource&lt;&#x2F;b&gt; string may have the following formats:
             *
             *  - &lt;code&gt;&quot;&#x2F;path&#x2F;to&#x2F;asset&lt;&#x2F;code&gt;: in this case the asset within
             * the current module will be loaded
             *
             *  - &lt;code&gt;&quot;module&quot;&lt;&#x2F;code&gt;: in this case the &quot;module&quot; within
             * &lt;code&gt;node_modules&lt;&#x2F;code&gt; folder will be required, and
             * afterwards the &lt;code&gt;&#x2F;modl&lt;&#x2F;code&gt; asset within the module will
             * be loaded.
             *
             *  - &lt;code&gt;&quot;module&#x2F;path&#x2F;to&#x2F;asset&quot;&lt;&#x2F;code&gt;: in this case the
             * &quot;module&quot; within &lt;code&gt;node_modules&lt;&#x2F;code&gt; folder will be
             * required, and afterwards the indicated asset within the module
             * will be loaded.
             *
             * Optionally an &lt;b&gt;alias&lt;&#x2F;b&gt; property may be passed to name the
             * required asset within the &lt;b&gt;imports&lt;&#x2F;b&gt; object. If
             * ommited, the alias will be automatically generated based the
             * &lt;b&gt;resource&lt;&#x2F;b&gt; value.
             *
             * @param {string} resource A given resource to be required
             * @param {string} [alias] An optional alias which to be named within the
             *            &lt;b&gt;imports&lt;&#x2F;b&gt; object.
             * @method require
             * @for modl
             * @static
             * @chainable
             * @return {Loader} The loader instance
             *&#x2F;
            require : function(resource, alias) {
                log(&quot;modl.require called, creating new loader&quot;);
                var loader = new Loader();
                return loader.require(resource, alias);
            },

            &#x2F;**
             * Creates a &lt;b&gt;Loader&lt;&#x2F;b&gt; and schedules a given &lt;b&gt;payload&lt;&#x2F;b&gt;
             * function export the &lt;i&gt;asset&lt;&#x2F;i&gt;. The &lt;b&gt;payload&lt;&#x2F;b&gt; will only
             * run when all the requires are loaded and ready for prime time.
             *
             * When called, the &lt;b&gt;payload&lt;&#x2F;b&gt; function will receive the
             * &lt;b&gt;module&lt;&#x2F;b&gt; struct as its first argument and as second
             * argument, the &lt;b&gt;imports&lt;&#x2F;b&gt; object containing all required
             * resources within will be passed.
             *
             * The &lt;b&gt;module&lt;&#x2F;b&gt; object will have an &lt;code&gt;exports&lt;&#x2F;code&gt;
             * property which will be published for this asset. This property
             * can be overwritten with any value this asset may want to publish (&lt;i&gt;a
             * la&lt;&#x2F;i&gt; nodejs module system).
             *
             * The &lt;b&gt;module&lt;&#x2F;b&gt; object will also have an &lt;code&gt;imports&lt;&#x2F;code&gt;
             * object containing all required resources which will be also
             * passed as a second argument to the &lt;b&gt;payload&lt;&#x2F;b&gt; function
             *
             * @method exports
             * @for modl
             * @static
             * @param {function} payload The payload function
             *&#x2F;
            exports : function(payload) {
                log(&quot;modl.exports called, creating new loader&quot;);
                var loader = new Loader();
                loader.exports(payload);
            },

            &#x2F;**
             * Sets up the modl environment. It will reset all loaded modules
             * and will set up the settings object along with the values passed
             * along with the &lt;b&gt;options&lt;&#x2F;b&gt; parameter.
             *
             * This function &lt;b&gt;MUST&lt;&#x2F;b&gt; be called before any require&#x2F;exports
             * can be actually made.
             *
             * @method setup
             * @for modl
             * @static
             * @param {object} options The options parameter
             * @param {string} options.root The root directory form which to load all
             *            assets and modules
             * @param {boolean} [options.debug] If this flag is on, it will emit debug
             *            messages to a console if available
             *&#x2F;
            setup : function(options) {
                settings = {};
                merge(settings, options, validSettings);
                current = new Module(&quot;&quot;, settings.root);
            }
        };

    if (node) {
        module.exports = modl;
    } else {
        global.modl = modl;
    }

}(this));
    </pre>
</div>

                    </div>
                </div>
            </div>
        </div>
    </div>
</div>
<script src="..&#x2F;assets/vendor/prettify/prettify-min.js"></script>
<script>prettyPrint();</script>
<script src="..&#x2F;assets/js/yui-prettify.js"></script>
<script src="..&#x2F;assets/../api.js"></script>
<script src="..&#x2F;assets/js/api-filter.js"></script>
<script src="..&#x2F;assets/js/api-list.js"></script>
<script src="..&#x2F;assets/js/api-search.js"></script>
<script src="..&#x2F;assets/js/apidocs.js"></script>
</body>
</html>
