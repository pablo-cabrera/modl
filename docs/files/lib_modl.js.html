<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>lib/modl.js - modl</title>
    <link rel="stylesheet" href="http://yui.yahooapis.com/3.9.1/build/cssgrids/cssgrids-min.css">
    <link rel="stylesheet" href="../assets/vendor/prettify/prettify-min.css">
    <link rel="stylesheet" href="../assets/css/main.css" id="site_styles">
    <link rel="shortcut icon" type="image/png" href="../assets/favicon.png">
    <script src="http://yui.yahooapis.com/combo?3.9.1/build/yui/yui-min.js"></script>
</head>
<body class="yui3-skin-sam">

<div id="doc">
    <div id="hd" class="yui3-g header">
        <div class="yui3-u-3-4">
            
                <h1><img src="../assets/css/logo.png" title="modl"></h1>
            
        </div>
        <div class="yui3-u-1-4 version">
            <em>API Docs for: 0.0.1</em>
        </div>
    </div>
    <div id="bd" class="yui3-g">

        <div class="yui3-u-1-4">
            <div id="docs-sidebar" class="sidebar apidocs">
                <div id="api-list">
    <h2 class="off-left">APIs</h2>
    <div id="api-tabview" class="tabview">
        <ul class="tabs">
            <li><a href="#api-classes">Classes</a></li>
            <li><a href="#api-modules">Modules</a></li>
        </ul>

        <div id="api-tabview-filter">
            <input type="search" id="api-filter" placeholder="Type to filter APIs">
        </div>

        <div id="api-tabview-panel">
            <ul id="api-classes" class="apis classes">
            
                <li><a href="../classes/Asset.html">Asset</a></li>
            
                <li><a href="../classes/Loader.html">Loader</a></li>
            
                <li><a href="../classes/modl.html">modl</a></li>
            
                <li><a href="../classes/modl.Util.html">modl.Util</a></li>
            
                <li><a href="../classes/modl.Util.Future.html">modl.Util.Future</a></li>
            
                <li><a href="../classes/modl.Util.Token.html">modl.Util.Token</a></li>
            
                <li><a href="../classes/Module.html">Module</a></li>
            
                <li><a href="../classes/Ready.html">Ready</a></li>
            
            </ul>

            <ul id="api-modules" class="apis modules">
            
            </ul>
        </div>
    </div>
</div>

            </div>
        </div>
        <div class="yui3-u-3-4">
                <div id="api-options">
        Show:
        <label for="api-show-inherited">
            <input type="checkbox" id="api-show-inherited" checked>
            Inherited
        </label>

        <label for="api-show-protected">
            <input type="checkbox" id="api-show-protected">
            Protected
        </label>

        <label for="api-show-private">
            <input type="checkbox" id="api-show-private">
            Private
        </label>
        <label for="api-show-deprecated">
            <input type="checkbox" id="api-show-deprecated">
            Deprecated
        </label>

    </div>


            <div class="apidocs">
                <div id="docs-main">
                    <div class="content">
                        <h1 class="file-heading">File: lib/modl.js</h1>

<div class="file">
    <pre class="code prettyprint linenums">
(function(global) {
    &quot;use strict&quot;;

    var
        /**
         * The default asset for a modl
         *
         * @property MODL_ASSET
         * @for modl
         * @type string
         * @static
         * @private
         * @final
         */
        MODL_ASSET = &quot;/modl&quot;,

        /**
         * The javascript file extension
         *
         * @property JS_EXTENSION
         * @for modl
         * @type string
         * @static
         * @private
         * @final
         */
        JS_EXTENSION = &quot;.js&quot;,

        /**
         * The node_modules directory path
         *
         * @property NODE_MODULES_PATH
         * @for modl
         * @type string
         * @static
         * @private
         * @final
         */
        NODE_MODULES_PATH = &quot;/node_modules/&quot;,

        /**
         * The regex to get the alias from the resource name
         *
         * @property ALIAS_RE
         * @for modl
         * @type RegEx
         * @static
         * @private
         * @final
         */
        ALIAS_RE = /(.*\/)?([^\/]+)$/,

        /**
         * The regex used to remove double (or more) slashes from a path
         *
         * @property PATH_RE
         * @for modl
         * @type RegEx
         * @static
         * @private
         * @final
         */
        PATH_RE = /\/{2,}/g,

        /**
         * A reference to the undefined value used internally
         *
         * @property undef
         * @for modl
         * @type undefined
         * @static
         * @private
         * @final
         */
        undef = void 0,

        objectProto = Object.prototype,

        arrayProto = Array.prototype,

        node = typeof exports !== &quot;undefined&quot; &amp;&amp; global.exports !== exports,

        constant = function(v) { return function() { return v; }; },

        k = constant(),

        /**
         * Array containing all
         *
         * @property node
         * @for modl
         * @type boolean
         * @static
         * @private
         * @final
         */
        validSettings = [&quot;debug&quot;, &quot;root&quot;],

        /**
         * Contains current settings for the modl loader
         *
         * @property settings
         * @for modl
         * @type Object
         * @static
         * @private
         */
        settings = null,

        /**
         * Points to the current module being loaded
         *
         * @property current
         * @for modl
         * @type Module
         * @static
         * @private
         */
        current,

        /**
         * Points to the asset being loaded at the moment
         *
         * @property loadingAsset
         * @for modl
         * @type Asset
         * @static
         * @private
         */
        loadingAsset,

        work = node ?
            function(f) { process.nextTick(f); } :
            function(f) { setTimeout(f, 0); },

        /**
         * Helper function to log messages when the debug flag is enabled
         *
         * @method log
         * @for modl
         * @param args* {mixed} Arguments to be logged
         * @private
         * @static
         */
        log = function() {
            var args;
            if (settings.debug &amp;&amp; console &amp;&amp; typeof console.log === &quot;function&quot;) {
                args = slice(arguments);
                args.unshift(ts());
                if (node) {
                    forEach(args, function(v, i) {
                        args[i] = require(&quot;util&quot;).inspect(v, {depth: null});
                    });
                }
                console.log.apply(this, args);
            }
        },

        /**
         * Returns a formatted current timestamp with &lt;code&gt;hh:mm:ss&lt;/code&gt; to be used for logging purposes
         *
         * @method ts
         * @for modl
         * @private
         * @static
         * @return {string} The formatted timestamp
         */
        ts = function() {
            var d = new Date(),
                z = function(n) { return n &lt; 10 ? &quot;0&quot; + n: String(n); };

            return &quot;[&quot; + z(d.getHours()) + &quot;:&quot; + z(d.getMinutes()) + &quot;:&quot; + z(d.getSeconds()) + &quot;.&quot; + String(1000 + d.getMilliseconds()).substr(1) + &quot;]&quot;;
        },

        hop = function(o, p) {
            return objectProto.hasOwnProperty.call(o, p);
        },

        merge = function(a, b, list) {
            if (list) {
                forEach(list, function(p) {
                    if (hop(b, p)) {
                        a[p] = b[p];
                    }
                });
            } else {
                forEach(b, function(v, p) {
                    a[p] = v;
                });
            }
        },

        indexOf = function(a, f) {
            var i = null,
                l;

            if (objectProto.toString.call(a) === &quot;[object Array]&quot;) {
                for (i = 0, l = a.length; i &lt; l; i += 1) {
                    if (f(a[i], i)) {
                        return i;
                    }
                }
            } else {
                for (i in a) {
                    if (hop(a, i)) {
                        if (f(a[i], i)) {
                            return i;
                        }
                    }
                }
            }
        },

        forEach = function(a, f) {
            indexOf(a, function(v, i) {
                f(v, i);
                return false;
            });
        },

        map = function(a, f) {
            var o = [];
            forEach(a, function(v, i) { o.push(f(v, i)); });
            return o;
        },

        slice = function() {
            var args = arrayProto.slice.call(arguments);
            return arrayProto.slice.apply(args.shift(), args);
        },

        overload = function() {
            var functions = {},
                args = slice(arguments);

            forEach(args, function(f) { functions[f.length] = f; });
            functions[&quot;default&quot;] = args[args.length - 1];

            return function() {
                var args = slice(arguments),
                    f = functions[args.length] || functions[&quot;default&quot;];

                return f.apply(this, args);
            };
        },

        that = function(f) {
            return function() {
                var args = slice(arguments);
                args.unshift(this);
                return f.apply(this, args);
            };
        },

        Token = (function() {
            var mark = typeof Object.defineProperty === &quot;function&quot; ?
                function(t) { return function(o, v) { Object.defineProperty(o, t, {enumerable: false, configurable: true, writable: true, value: v}); }; } :
                function(t) { return function(o, v) { o[t] = v; }; };

            return function(token) {

                /**
                 * Token&#x27;s toString
                 *
                 * @method toString
                 * @for modl.Util.Token
                 * @return {string}
                 */
                this.toString = constant(token);

                /**
                 * Token&#x27;s valueOf
                 *
                 * @method valueOf
                 * @for modl.Util.Token
                 * @return {string}
                 */
                this.valueOf = this.toString;

                /**
                 * Defines the token as a property for the given object
                 *
                 * @method mark
                 * @for modl.Util.Token
                 * @param {object} o
                 * @param {mixed} [v] Optional value
                 */
                this.mark = mark(token);
            };
        }()),

        token = (function() {
            var
                chars = &quot;abcdefghijklmnopqrstwxyzABCDEFGHIJKLMNOPQRSTWXYZ&quot;,
                length = chars.length,
                lastChar = chars.charAt(chars.length - 1),
                firstChar = chars.charAt(0),
                id = [],
                suffix = [];

            while (suffix.length &lt; 32) {
                suffix.push(chars.charAt(Math.floor(Math.random() * length)));
            }
            suffix = suffix.join(&quot;&quot;);

            return function() {
                var i, c;
                for (i = id.length - 1; i &gt; -1; i -= 1) {
                    c = id[i];
                    if (c !== lastChar) {
                        id[i] = chars.charAt(chars.indexOf(c) + 1);
                        break;
                    }

                    id[i] = firstChar;
                }

                if (i === -1) {
                    id.unshift(firstChar);
                }

                return new Token(id.join(&quot;&quot;) + suffix);
            };
        }()),

        kin = (function() {

            var
                define = function(o, p, v) {
                    if (p instanceof Token) {
                        p.mark(o, v);
                    } else {
                        o[p] = v;
                    }
                },

                utils = {
                    proto: overload(
                        function(constructor, values) {
                            forEach(values, function(v, p) { constructor.proto(p, v); });
                            return constructor;
                        },
                        function(constructor, name, value) {
                            define(constructor.prototype, name, value);
                            return constructor;
                        }),

                    descend: function(constructor, descendant) {
                        var F = function() {};
                        F.prototype = constructor.prototype;
                        descendant.prototype = new F();
                        prepare(descendant);
                        descendant.ancestor = constructor.prototype;
                        return descendant;
                    },

                    constant: function(constructor, name) {
                        if (name in constructor) {
                            return constructor[name];
                        }

                        if (&quot;ancestor&quot; in constructor) {
                            return constructor.ancestor.constructor.constant(name);
                        }
                    },

                    defConstant: overload(
                        function(constructor, values) {
                            forEach(values, function(v, p) { constructor.defConstant(p, v); });
                            return constructor;
                        },

                        function(constructor, name, value) {
                            define(constructor, name, value);
                            return constructor;
                        })

                },

                prepare = function(constructor) {
                    constructor.prototype.constructor = constructor;

                    forEach(utils, function(f, p) {
                        constructor[p] = function() {
                            var args = slice(arguments);
                            args.unshift(this);
                            return f.apply(this, args);
                        };
                    });
                };

            return function(constructor) {
                prepare(constructor);
                return constructor;
            };
        }()),

        preloadedResources = {},

        preloadResources = function(path, module) {
            forEach(module, function(content, resource) {
                if (resource.indexOf(&quot;/&quot;) === 0) {
                    preloadedResources[path + resource + JS_EXTENSION] = content;
                } else {
                    preloadResources(path + NODE_MODULES_PATH + resource, content);
                }
            });
        },

        loadResource = function(resource) {
            if (hop(preloadedResources, resource)) {
                work(function() { preloadedResources[resource].call(global); });
            } else {
                loadScript(resource);
            }
        },

        /**
         * Loads a given script.
         *
         * @method loadScript
         * @for modl
         * @static
         * @private
         * @param {string} src The script&#x27;s src
         */
        loadScript = node?
            function(src) {
                delete require.cache[src];
                work(function() { require(src); });
            }:
            function(src) {
                var s = document.createElement(&quot;script&quot;),
                    d = document.documentElement;
                s.src = src;
                d.insertBefore(s, d.firstChild);
            },

        /**
         * The Ready class provides the functionality of scheduling callbacks
         * for when a given Ready instance is marked as ready
         *
         * @class Ready
         * @constructor
         * @private
         */
        Ready = (function() {
            var
                readyStatus = token(),
                callbacks = token();

            return kin(function() {
                    /**
                     * Indicates whether the instance is ready or not
                     *
                     * @property readyStatus
                     * @for Ready
                     * @private
                     * @type {boolean}
                     */
                    readyStatus.mark(this, false);

                    /**
                     * Callback functions are stored within this guy
                     *
                     * @property callbacks
                     * @for Ready
                     * @private
                     * @type {array}
                     */
                    callbacks.mark(this, []);
                }).

                proto({
                    /**
                     * Schedules an &lt;b&gt;f&lt;/b&gt; callback to be executed once the
                     * instance is marked as &lt;b&gt;ready&lt;/b&gt;
                     *
                     * @method whenReady
                     * @for Ready
                     * @param {function} f The callback function to be scheduled
                     */
                    whenReady: function(f) {
                        if (this[readyStatus]) {
                            f();
                        } else {
                            this[callbacks].push(f);
                        }
                    },

                    /**
                     * Marks the instance as &lt;b&gt;ready&lt;/b&gt; and runs all it&#x27;s callbacks
                     *
                     * @method ready
                     * @for Ready
                     */
                    ready: function() {
                        this[readyStatus] = true;
                        forEach(this[callbacks], function(f) { f(); });
                    }
                });
        }()),

        /**
         * The Asset class represents an script file being loaded within a
         * module.
         *
         * @class Asset
         * @extends Ready
         * @constructor
         * @private
         * @param {string} name It&#x27;s name
         */
        Asset = (function() {
            var _name = token();

            return Ready.descend(function(name, path) {

                /**
                 * The asset&#x27;s name
                 *
                 * @property _name
                 * @for Asset
                 * @type {string}
                 * @private
                 */

                _name.mark(this, name);

                /**
                 * Holds the asset&#x27;s exports
                 *
                 * @property exports
                 * @for Asset
                 * @type {mixed}
                 */
                this.exports = undef;

                Ready.call(this);

                log(&quot;Asset created: &quot;, this);
            }).

            /**
             * Retrieves the asset and loads it
             *
             * @param {string} path It&#x27;s path
             */
            proto(&quot;load&quot;, function(path) {
                loadingAsset = this;
                loadResource((path + this[_name] + JS_EXTENSION).replace(PATH_RE, &quot;/&quot;));
            });
        }()),

        /**
         * The Module class represents a module within the modl tree. It can
         * load other &lt;b&gt;modules&lt;/b&gt;(dependencies contained within
         * &lt;code&gt;node_modules&lt;/code&gt; directory) and &lt;b&gt;assets&lt;/b&gt; (files
         * referenced within a module).
         *
         * @class Module
         * @extends Ready
         * @constructor
         * @private
         * @param {string} name The module&#x27;s name
         * @param {string} path The module&#x27;s path
         */
        Module = (function() {
            var _name = token(),
                _path = token(),
                modules = token(),
                assets = token();

            return Ready.descend(function(name, path) {
                    /**
                     * It&#x27;s name
                     *
                     * @property _name
                     * @for Module
                     * @private
                     * @type {string}
                     */
                    _name.mark(this, name);

                    /**
                     * It&#x27;s path
                     *
                     * @property _path
                     * @for Module
                     * @private
                     * @type {string}
                     */
                    _path.mark(this, path);

                    /**
                     * It&#x27;s inner modules. This will contain the references for
                     * the children modules currently loaded for this module.
                     *
                     * @property _modules
                     * @for Module
                     * @private
                     * @type {object}
                     */
                    modules.mark(this, {});

                    /**
                     * It&#x27;s assets. This will contain the references for all
                     * assets currently loaded within this module.
                     *
                     * @property _assets
                     * @for Module
                     * @private
                     * @type {object}
                     */
                    assets.mark(this, {});

                    /**
                     * Holds the asset&#x27;s exports
                     *
                     * @property exports
                     * @for Module
                     * @type {mixed}
                     */
                    this.exports = undef;


                    Ready.call(this);
                    log(&quot;module created: &quot;, this);

                    this.initialize();
                }).

                proto({

                    /**
                     * Initializes the module loading its &lt;code&gt;/modl&lt;/code&gt; asset
                     *
                     * @method initialize
                     * @for Module
                     */
                    initialize: that(function(that) {
                        if (this[_name] !== &quot;&quot;) {
                            this.asset(MODL_ASSET).
                            when(function(err, asset) {
                                that.exports = asset.exports;
                                that.ready();
                            });
                        } else {
                            this.ready();
                        }
                    }),

                    /**
                     * Loads an asset within the module.
                     *
                     * @method asset
                     * @for Module
                     * @param {string} name The asset&#x27;s name
                     * @return {modl.Util.Future} The future representing when the asset will
                     *         be loaded
                     */
                    asset: function(name) {
                        var future = new Future(),
                            asset;

                        if (name in this[assets]) {
                            asset = this[assets][name];
                        } else {
                            asset = new Asset(name);
                            asset.load(this[_path]);
                            this[assets][name] = asset;
                        }

                        asset.whenReady(function() {
                            future.fulfill(null, asset);
                        });

                        return future;
                    },

                    /**
                     * Loads child module within the module &lt;i&gt;(Yo dawg! I heard you like modules...)&lt;/i&gt;.
                     *
                     * @method module
                     * @for Module
                     * @param {string} name The module&#x27;s name
                     * @return {modl.Util.Future} The future representing when the module will
                     *         be loaded
                     */
                    module: that(function(that, name) {
                        var future = new Future(),
                            module;

                        if (name in this[modules]) {
                            module = this[modules][name];
                        } else {
                            module = new Module(name, this[_path] + &quot;/node_modules/&quot; + name);
                            this[modules][name] = module;
                        }

                        current = module;

                        module.whenReady(function() {
                            current = that;
                            future.fulfill(null, module);
                        });

                        return future;
                    }),

                    $modl: function(module) {
                        preloadResources(this[_path], module);
                        work(function() { module[MODL_ASSET].call(global); });
                    }

                });
        }()),

        Future = (function() {
            var _err = token(),
                _data = token(),
                fulfilled = token(),
                when = token(),
                runWhen = token();

            return kin(function() {

                /**
                 * Holds the sent error
                 *
                 * @property _err
                 * @for modl.Util.Future
                 * @private
                 * @type {mixed}
                 */
                _err.mark(this);

                /**
                 * Holds the sent data
                 *
                 * @property _data
                 * @for modl.Util.Future
                 * @private
                 * @type {mixed}
                 */
                _data.mark(this);

                /**
                 * Indicates whether the promise has been fulfilled
                 *
                 * @property fulfilled
                 * @for modl.Util.Future
                 * @private
                 * @type {boolean}
                 */
                fulfilled.mark(this, false);

                /**
                 * Holds the callback to be executed whenever the promise is fulfilled
                 *
                 * @property when
                 * @for modl.Util.Future
                 * @private
                 * @type {function}
                 */

                when.mark(this, k);
            }).

            proto(runWhen, that(function(that, when) {
                work(function() { when.call(null, that[_err], that[_data]); });
            })).

            proto({

                /**
                 * Fulfills the promise
                 *
                 * @method fulfill
                 * @for modl.Util.Future
                 * @param {mixed} [err] The error to be sent
                 * @param {mixed} [data] The data to be sent
                 */
                fulfill: that(function(that, err, data) {
                    if (this[fulfilled]) {
                        throw new Error(&quot;Future already fulfilled&quot;);
                    }

                    this[_err] = err;
                    this[_data] = data;
                    this[fulfilled] = true;
                    this[runWhen](this[when]);
                }),

                /**
                 * Register the callback if the promise is to be fulfilled,
                 * otherwise just runs it passing along the error/data
                 * associated with the future
                 *
                 * @method when
                 * @for modl.Util.Future
                 * @param {function} f The callback function
                 */
                when: function(f) {
                    if (this[fulfilled]) {
                        this[runWhen](f);
                    } else {
                        this[when] = f;
                    }
                }
            });
        }()),

        /**
         * The loader class responsible for loading the various dependencies between modules and assets
         *
         * @class Loader
         * @extends Ready
         * @constructor
         * @private
         */
        Loader = (function() {
            var requires = token(),
                modl = token(),
                _payload = token(),
                attachAsset = token(),
                dispatch = token(),
                loadRequires = token(),
                loadRequire = token();

            return Ready.descend(function() {
                /**
                 * The requires collection containing the various required
                 * data
                 *
                 * @property requires
                 * @for Loader
                 * @private
                 * @type {object}
                 */
                requires.mark(this, {});

                /**
                 * The modl instance to be passed along to the exports
                 * callback function when called
                 *
                 * @property modl
                 * @for Loader
                 * @private
                 * @type {object}
                 */
                modl.mark(this, {
                    imports: {},
                    exports: {}
                });

                /**
                 * The callback function to be executed when all the
                 * requires are ready
                 *
                 * @property _payload
                 * @for Loader
                 * @private
                 * @type {function}
                 */
                _payload.mark(this, k);

                Ready.call(this);

                log(&quot;loader created: &quot;, this);
            }).

            /**
             * Attach a given asset to this Loader. When the loader is
             * ready, the asset will also be market as ready
             *
             * @method attachAsset
             * @for Loader
             * @private
             * @param {Asset} asset The asset to be attached
             */
            proto(attachAsset, that(function(that, asset) {
                this.whenReady(function() {
                    log(&quot;loader ready, triggering asset&quot;);
                    asset.exports = that[modl].exports;
                    asset.ready();
                });
            })).

            /**
             * Dispatches the loader processing. It will start loading all
             * its requires and finally will run the payload function.
             *
             * @method dispatch
             * @for Loader
             * @private
             */
            proto(dispatch, that(function(that) {
                var aliases = {};
                forEach(this[requires], function(alias, require) {
                    if (!alias) {
                        that[requires][require] = alias = require.replace(ALIAS_RE, &quot;$2&quot;);
                    }

                    if (hop(aliases, alias)) {
                        throw new Error(&quot;Alias clash: &quot; + alias);
                    }

                    aliases[alias] = undef;
                });


                that[loadRequires]().
                when(function() {
                    log(&quot;Running payload&quot;);
                    that[_payload].call(null, that[modl], that[modl].imports);
                    that.ready();
                });
            })).

            /**
             * Loads all requires for the loader.
             *
             * @method loadRequires
             * @for Loader
             * @private
             * @return {modl.Util.Future} A promise for when all the requires are ready.
             */
            proto(loadRequires, that(function(that) {
                var future = new Future(),
                    reqs = map(this[requires], function(v, k) { return k; }),
                    load = function(require) {
                        if (!require) {
                            log(&quot;done loading requires, moving on&quot;);
                            future.fulfill();
                        } else {
                            that[loadRequire](require).
                            when(function() { load(reqs.shift()); });
                        }
                    };

                log(&quot;loading requires&quot;);

                load(reqs.shift());
                return future;
            })).

            /**
             * Loads a given require
             *
             * @method loadRequire
             * @for Loader
             * @private
             * @param {string} require The require name
             * @return {modl.Util.Future} The promise for when the require is done
             */
            proto(loadRequire, that(function(that, require) {
                var
                    alias = this[requires][require],
                    future = new Future(),

                    when = function(err, thing) {
                        log(&quot;Require loaded: &quot;, require);
                        that[modl].imports[alias] = thing.exports;
                        future.fulfill();
                    };

                log(&quot;loading require: &quot;, require, alias);

                if (require.indexOf(&quot;/&quot;) === 0) {
                    current.asset(require).
                    when(when);
                } else {
                    current.module(require).
                    when(when);
                }

                return future;
            })).

            proto({

                /**
                 * Requires an asset from it. The &lt;b&gt;resource&lt;/b&gt; string may
                 * have the following formats:
                 *
                 *  - &lt;code&gt;&quot;/path/to/asset&lt;/code&gt;: in this case the asset
                 * within the current module will be loaded
                 *
                 *  - &lt;code&gt;&quot;module&quot;&lt;/code&gt;: in this case the &quot;module&quot; within
                 * &lt;code&gt;node_modules&lt;/code&gt; folder will be required, and
                 * afterwards the &lt;code&gt;/modl&lt;/code&gt; asset within the module
                 * will be loaded.
                 *
                 *  - &lt;code&gt;&quot;module/path/to/asset&quot;&lt;/code&gt;: in this case the
                 * &quot;module&quot; within &lt;code&gt;node_modules&lt;/code&gt; folder will be
                 * required, and afterwards the indicated asset within the
                 * module will be loaded.
                 *
                 * Optionally an &lt;b&gt;alias&lt;/b&gt; property may be passed to name
                 * the required asset within the &lt;b&gt;imports&lt;/b&gt; object. If
                 * ommited, the alias will be automatically generated based the
                 * &lt;b&gt;resource&lt;/b&gt; value.
                 *
                 * @param {string} resource A given resource to be required
                 * @param {string} [alias] An optional alias which to be named
                 *              within the &lt;b&gt;imports&lt;/b&gt; object.
                 * @method require
                 * @for Loader
                 * @chainable
                 * @return {Loader} The loader instance
                 */
                require: function(resource, alias) {
                    this[requires][resource] = alias;
                    return this;
                },

                /**
                 * Schedules a given &lt;b&gt;payload&lt;/b&gt;
                 * function export the &lt;i&gt;asset&lt;/i&gt;. The &lt;b&gt;payload&lt;/b&gt; will only
                 * run when all the requires are loaded and ready for prime time.
                 *
                 * When called, the &lt;b&gt;payload&lt;/b&gt; function will receive the
                 * &lt;b&gt;module&lt;/b&gt; struct as its first argument and as second
                 * argument, the &lt;b&gt;imports&lt;/b&gt; object containing all required
                 * resources within will be passed.
                 *
                 * The &lt;b&gt;module&lt;/b&gt; object will have an &lt;code&gt;exports&lt;/code&gt;
                 * property which will be published for this asset. This property
                 * can be overwritten with any value this asset may want to publish (&lt;i&gt;a
                 * la&lt;/i&gt; nodejs module system).
                 *
                 * The &lt;b&gt;module&lt;/b&gt; object will also have an &lt;code&gt;imports&lt;/code&gt;
                 * object containing all required resources which will be also
                 * passed as a second argument to the &lt;b&gt;payload&lt;/b&gt; function
                 *
                 * @method exports
                 * @for Loader
                 * @param {function} payload The payload function
                 */
                exports: function(payload) {
                    this[_payload] = payload;
                    if (loadingAsset !== undef) {
                        this[attachAsset](loadingAsset);
                        loadingAsset = undef;
                    }
                    this[dispatch]();
                }
            });
        }()),

        /**
         * The modl loader
         *
         * @class modl
         * @static
         */
        modl = {

            /**
             * Creates a &lt;b&gt;Loader&lt;/b&gt; and requires an asset from it. The
             * &lt;b&gt;resource&lt;/b&gt; string may have the following formats:
             *
             *  - &lt;code&gt;&quot;/path/to/asset&lt;/code&gt;: in this case the asset within
             * the current module will be loaded
             *
             *  - &lt;code&gt;&quot;module&quot;&lt;/code&gt;: in this case the &quot;module&quot; within
             * &lt;code&gt;node_modules&lt;/code&gt; folder will be required, and
             * afterwards the &lt;code&gt;/modl&lt;/code&gt; asset within the module will
             * be loaded.
             *
             *  - &lt;code&gt;&quot;module/path/to/asset&quot;&lt;/code&gt;: in this case the
             * &quot;module&quot; within &lt;code&gt;node_modules&lt;/code&gt; folder will be
             * required, and afterwards the indicated asset within the module
             * will be loaded.
             *
             * Optionally an &lt;b&gt;alias&lt;/b&gt; property may be passed to name the
             * required asset within the &lt;b&gt;imports&lt;/b&gt; object. If
             * ommited, the alias will be automatically generated based the
             * &lt;b&gt;resource&lt;/b&gt; value.
             *
             * @param {string} resource A given resource to be required
             * @param {string} [alias] An optional alias which to be named within the
             *            &lt;b&gt;imports&lt;/b&gt; object.
             * @method require
             * @for modl
             * @static
             * @chainable
             * @return {Loader} The loader instance
             */
            require: function(resource, alias) {
                log(&quot;modl.require called, creating new loader&quot;);
                var loader = new Loader();
                return loader.require(resource, alias);
            },

            /**
             * Creates a &lt;b&gt;Loader&lt;/b&gt; and schedules a given &lt;b&gt;payload&lt;/b&gt;
             * function export the &lt;i&gt;asset&lt;/i&gt;. The &lt;b&gt;payload&lt;/b&gt; will only
             * run when all the requires are loaded and ready for prime time.
             *
             * When called, the &lt;b&gt;payload&lt;/b&gt; function will receive the
             * &lt;b&gt;module&lt;/b&gt; struct as its first argument and as second
             * argument, the &lt;b&gt;imports&lt;/b&gt; object containing all required
             * resources within will be passed.
             *
             * The &lt;b&gt;module&lt;/b&gt; object will have an &lt;code&gt;exports&lt;/code&gt;
             * property which will be published for this asset. This property
             * can be overwritten with any value this asset may want to publish (&lt;i&gt;a
             * la&lt;/i&gt; nodejs module system).
             *
             * The &lt;b&gt;module&lt;/b&gt; object will also have an &lt;code&gt;imports&lt;/code&gt;
             * object containing all required resources which will be also
             * passed as a second argument to the &lt;b&gt;payload&lt;/b&gt; function
             *
             * @method exports
             * @for modl
             * @static
             * @param {function} payload The payload function
             */
            exports: function(payload) {
                log(&quot;modl.exports called, creating new loader&quot;);
                var loader = new Loader();
                loader.exports(payload);
            },

            /**
             * Sets up the modl environment. It will reset all loaded modules
             * and will set up the settings object along with the values passed
             * along with the &lt;b&gt;options&lt;/b&gt; parameter.
             *
             * This function &lt;b&gt;MUST&lt;/b&gt; be called before any require/exports
             * can be actually made.
             *
             * @method setup
             * @for modl
             * @static
             * @param {object} options The options parameter
             * @param {string} options.root The root directory form which to load all
             *            assets and modules
             * @param {boolean} [options.debug] If this flag is on, it will emit debug
             *            messages to a console if available
             */
            setup: function(options) {
                settings = {};
                merge(settings, options, validSettings);
                current = new Module(&quot;&quot;, settings.root);
            },


            $modl: function(module) {
                current.$modl(module);
            },

            /**
             * Util class that provides inner utils to the outside world
             *
             * @class modl.Util
             * @static
             */
            Util: {

                /**
                 * Flag that indicates if we are running under nodejs environment
                 *
                 * @property Uode
                 * @for modl.Util
                 * @type boolean
                 * @final
                 */
                node: node,

                /**
                 * Returns a function that always returns the same value
                 *
                 * @method constant
                 * @for modl.Util
                 * @param {mixed} v Returned value
                 * @return {function}
                 */
                constant: constant,

                /**
                 * Short for setTimeout(f, 0);
                 *
                 * @method work
                 * @for modl.Util
                 * @param {function} f Work function
                 * @return {number} timeout id
                 */
                work: work,

                /**
                 * Short for Object.prototype.hasOwnProperty
                 *
                 * @method hop
                 * @for modl
                 * @param {object} o Object to check its property
                 * @param {string} p Property name
                 * @return {boolean} whether a property exists within the object or not
                 */
                hop: hop,

                /**
                 * Merges all properties from &lt;b&gt;b&lt;/b&gt; into &lt;b&gt;a&lt;/b&gt;. Optionally it
                 * can be passes a property whitelist
                 *
                 * @method merge
                 * @for modl.Util
                 * @param {object} a The target object
                 * @param {object} b The source object
                 * @param {array} [list] Properties whitelist
                 */
                merge: merge,

                /**
                 * Iterates over an object&#x27;s properties or an array&#x27;s values calling the
                 * &lt;b&gt;f&lt;/b&gt; callback function each time passing the value as it&#x27;s first
                 * argument and the index or property name as it&#x27;s second argument. The
                 * callback function must return either &lt;code&gt;true&lt;/code&gt; or
                 * &lt;code&gt;false&lt;/code&gt;. If for a given property or index the function
                 * returns &lt;code&gt;true&lt;/code&gt; then the indexOf function will return the
                 * current property name or index.
                 *
                 * @method indexOf
                 * @for modl.Util
                 * @param {array|object} a The array or object to be iterated
                 * @param {function} f The callback function for each iteration
                 */
                indexOf: indexOf,

                /**
                 * Iterates over an object&#x27;s properties or an array&#x27;s values calling the
                 * &lt;b&gt;f&lt;/b&gt; callback function each time passing the value as it&#x27;s first
                 * argument and the index or property name as it&#x27;s second argument.
                 *
                 * @method forEach
                 * @for modl.Util
                 * @param {array|object} a The array or object to be iterated
                 * @param {function} f The callback function for each iteration
                 */
                forEach: forEach,

                /**
                 * Short for Array.prototype.slice.apply(arguments[0], arguments[1...n])
                 *
                 * @method slice
                 * @for modl.Util
                 * @return {array}
                 */
                slice: slice,

                /**
                 * Iterates over an object&#x27;s properties or an array&#x27;s values
                 * calling the &lt;b&gt;f&lt;/b&gt; callback function each time passing the
                 * value as it&#x27;s first argument and the index or property name
                 * as it&#x27;s second argument. The returned value of each function
                 * call is stored in a new array that is returned in the end.
                 *
                 * @method map
                 * @for modl.Util
                 * @param {array|object} a The array or object to be iterated
                 * @param {function} f The callback function for each iteration
                 * @return {array}
                 */
                map: map,

                /**
                 * Returns a function that decides which function to call based on the number of arguments passed.
                 *
                 * @method overload
                 * @for modl.Util
                 * @param {function} functions*
                 * @return {function}
                 */
                overload: overload,

                /**
                 * Returns another function that passes the this arguments as first argument to the other function
                 *
                 * @method that
                 * @for modl.Util
                 * @param {function} f Function that receives &quot;this&quot; as &quot;that&quot;
                 * @return {function}
                 */
                that: that,

                /**
                 * Creates a unique token
                 *
                 * @method token
                 * @for modl.Util
                 * @return {modl.Util.Token}
                 */
                token: token,

                /**
                 * Creates new classes of things
                 *
                 * @method kin
                 * @for modl.Util
                 * @param {function} constructor
                 * @return {function} A new kin, or class if you may
                 */
                kin: kin,

                /**
                 * A noop function
                 *
                 * @method k
                 * @for modl.Util
                 */
                k: k,

                /**
                 * Token class
                 *
                 * @class modl.Util.Token
                 * @constructor
                 * @param {string} token Token value
                 */
                Token: Token,

                /**
                 * Represents a future promise
                 *
                 * @class modl.Util.Future
                 * @constructor
                 */
                Future: Future
            }
        };

    if (node) {
        module.exports = modl;
    } else {
        global.modl = modl;
    }

}(this));
    </pre>
</div>

                    </div>
                </div>
            </div>
        </div>
    </div>
</div>
<script src="../assets/vendor/prettify/prettify-min.js"></script>
<script>prettyPrint();</script>
<script src="../assets/js/yui-prettify.js"></script>
<script src="../assets/../api.js"></script>
<script src="../assets/js/api-filter.js"></script>
<script src="../assets/js/api-list.js"></script>
<script src="../assets/js/api-search.js"></script>
<script src="../assets/js/apidocs.js"></script>
</body>
</html>
