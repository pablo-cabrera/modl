(function(global) {
    "use strict";

    var
        /**
         * The defaults asset for a modl
         *
         * @property MODL_ASSET
         * @for modl
         * @type string
         * @static
         * @private
         * @final
         */
        MODL_ASSET = "/modl",

        /**
         * The regex to parse a resource
         *
         * @property RESOURCE_RE
         * @for modl
         * @type RegEx
         * @static
         * @private
         * @final
         */
        RESOURCE_RE = /([^\/]*)(\/.+)?/,

        /**
         * The regex to get the alias from the resource name
         *
         * @property ALIAS_RE
         * @for modl
         * @type RegEx
         * @static
         * @private
         * @final
         */
        ALIAS_RE = /(.*\/)?([^\/]+)$/,

        /**
         * The regex used to remove double (or more) slashes from a path
         *
         * @property PATH_RE
         * @for modl
         * @type RegEx
         * @static
         * @private
         * @final
         */
        PATH_RE = /\/{2,}/g,

        /**
         * A reference to the undefined value used internally
         *
         * @property undef
         * @for modl
         * @type undefined
         * @static
         * @private
         * @final
         */
        undef = void 0,

        /**
         * Flag that indicates if we are running under nodejs environment
         *
         * @property node
         * @type boolean
         * @static
         * @private
         * @final
         */
        node = typeof exports !== "undefined" && global.exports !== exports,

        /**
         * Array containing all
         *
         * @property node
         * @for modl
         * @type boolean
         * @static
         * @private
         * @final
         */
        validSettings = ["debug", "root"],

        /**
         * Contains current settings for the modl loader
         *
         * @property settings
         * @for modl
         * @type Object
         * @static
         * @private
         */
        settings = null,

        /**
         * Points to the current module being loaded
         *
         * @property current
         * @for modl
         * @type Module
         * @static
         * @private
         */
        current,

        /**
         * Points to the asset being loaded at the moment
         *
         * @property loadingAsset
         * @for modl
         * @type Asset
         * @static
         * @private
         */
        loadingAsset,

        /**
         * Helper function to log messages when the debug flag is enabled
         *
         * @method log
         * @for modl
         * @param args* {mixed} Arguments to be logged
         * @private
         * @static
         */
        log = function() {
            var args, d;
            if (settings.debug && console && typeof console.log === "function") {
                args = Array.prototype.slice.call(arguments);
                args.unshift(ts());
                console.log.apply(this, args);
            }
        },

        /**
         * Returns a formatted current timestamp with <code>hh:mm:ss</code> to be used for logging purposes
         *
         * @method ts
         * @for modl
         * @private
         * @static
         * @return {string} The formatted timestamp
         */
        ts = function() {
            var d = new Date(),
                z = function(n) { return n < 10 ? "0" + n : String(n); };

            return "[" + z(d.getHours()) + ":" + z(d.getMinutes()) + ":" + z(d.getSeconds()) + "]";
        },

        /**
         * Short for Object.prototype.hasOwnProperty
         *
         * @method hop
         * @for modl
         * @private
         * @static
         * @param {object} o Object to check its property
         * @param {string} p Property name
<<<<<<< HEAD
         * @return {boolean} Wether a property exists within the object or not
=======
         * @return {boolean} whether a property exists within the object or not
>>>>>>> gh-pages
         */
        hop = function(o, p) {
            return Object.prototype.hasOwnProperty.call(o, p);
        },

        /**
         * Merges all properties from <b>b</b> into <b>a</b>. Optionally it
         * can be passes a property whitelist
         *
         * @method merge
         * @for modl
         * @private
         * @static
         * @param {object} a The target object
         * @param {object} b The source object
         * @param {array} [list] Properties whitelist
         */
        merge = function(a, b, list) {
            if (list) {
                forEach(list, function(p) {
                    if (hop(b, p)) {
                        a[p] = b[p];
                    }
                });
            } else {
                forEach(b, function(v, p) {
                    a[p] = v;
                });
            }
        },

        /**
         * Iterates over an object's properties or an array's values calling the
         * <b>f</b> callback function each time passing the value as it's first
         * argument and the index or property name as it's second argument.
         *
         * @method forEach
         * @for modl
         * @private
         * @static
         * @param {array|object} a The array or object to be iterated
         * @param {function} f The callback function for each iteration
         */
        forEach = function(a, f) {
            indexOf(a, function(v, i) {
                f(v, i);
                return false;
            });
        },

        /**
         * Iterates over an object's properties or an array's values calling the
         * <b>f</b> callback function each time passing the value as it's first
         * argument and the index or property name as it's second argument. The
         * callback function must return either <code>true</code> or
         * <code>false</code>. If for a given property or index the function
         * returns <code>true</code> then the indexOf function will return the
         * current property name or index.
         *
         * @method indexOf
         * @for modl
         * @private
         * @static
         * @param {array|object} a The array or object to be iterated
         * @param {function} f The callback function for each iteration
         */
        indexOf = function(a, f) {
            var i, l;

            if (Object.prototype.toString.call(a) === "[object Array]") {
                for (i = 0, l = a.length; i < l; i += 1) {
                    if (f(a[i], i)) {
                        return i;
                    }
                }
            } else {
                for (i in a) {
                    if (hop(a, i)) {
                        if (f(a[i], i)) {
                            return i;
                        }
                    }
                }
            }
        },

        /**
         * A type creator helper. This function will construct a pseudo-class
         * using the <b>specs</b> object for it's definition.
         *
         * The <b>specs</b> object must have a <b>constr</b> object for it
         * will be used as the constructor function. Optionally, it could have a
         * <b>proto</b> object that may contain properties which will be
         * augmented to the constructor's prototype.
         *
         * The constructor function will have a <b>descend</b> method that can
         * be called to create another type using the same constraints as the
         * <b>type</b> method, plus the child constructor will have an
         * <b>ancestor</b> property which will reference the parent's
         * prototype.
         *
         * @method type
         * @for modl
         * @private
         * @static
         * @param {object} specs The specs object
         * @param {function} specs.constr The constructor function
         * @param {object} [specs.proto] Object containing properties to augment the constructor's prototype with
         * @return {function} The new created type
         */
        type = function(specs) {
            var constr = specs.constr || function() {};
            if (specs.proto) {
                merge(constr.prototype, specs.proto);
            }

            constr.descend = function(specs) {
                var child = specs.constr || function() {},
                    F = function() {};

                F.prototype = constr.prototype;
                child.prototype = new F();
                child.prototype.constructor = child;
                child.ancestor = constr.prototype;

                if (specs.proto) {
                    merge(child.prototype, specs.proto);
                }

                return child;
            };

            return constr;
        },

        /**
         * Parses a require struct into a resource
         *
         * @method parseResource
         * @for modl
         * @static
         * @private
         * @param {object} require The require struct
         * @return {object} The parsed resource
         */
        parseResource = function(require) {
            var matches = require.resource.match(RESOURCE_RE),
                alias = require.alias,
                module = matches[1],
                asset = matches[2],
                aliasRe;

            if (!alias) {
                if (module) {
                    if (asset) {
                        alias = asset.replace(ALIAS_RE, "$2");
                    } else {
                        alias = module;
                        asset = MODL_ASSET;
                    }
                } else {
                    alias = asset.replace(ALIAS_RE, "$2");
                }
            }

            if (!asset) {
                asset = MODL_ASSET;
            }

            return {
                module : matches[1],
                asset : asset,
                alias : alias
            };
        },

        /**
         * Loads a given script.
         *
         * @method loadScript
         * @for modl
         * @static
         * @private
         * @param {string} src The script's src
         */
        loadScript = (function() {
            return node ?
                function(src) {
                    delete require.cache[src];
                    require(src);
                } :
                function(src) {
                    var s = document.createElement("script"),
                        d = document.documentElement;
                    s.src = src;
                    d.insertBefore(s, d.firstChild);
                };
        }()),

        /**
         * The Ready class provides the functionality of scheduling callbacks
         * for when a given Ready instance is marked as ready
         *
         * @class Ready
         * @constructor
         * @private
         */
        Ready = type({
            constr : function() {
                merge(this, {
                    /**
<<<<<<< HEAD
                     * Indicates wether the instance is ready or not
=======
                     * Indicates whether the instance is ready or not
>>>>>>> gh-pages
                     *
                     * @property _readyStatus
                     * @for Ready
                     * @private
                     * @type {boolean}
                     */
                    _readyStatus : false,

                    /**
                     * Callback functions are stored within this guy
                     *
                     * @property _callbacks
                     * @for Ready
                     * @private
                     * @type {array}
                     */
                    _callbacks : []
                });
            },

            proto : {
                /**
                 * Schedules an <b>f</b> callback to be executed once the
                 * instance is marked as <b>ready</b>
                 *
                 * @method _whenReady
                 * @for Ready
                 * @private
                 * @param {function} f The callback function to be scheduled
                 */
                _whenReady : function(f) {
                    if (this._readyStatus) {
                        f();
                    } else {
                        this._callbacks.push(f);
                    }
                },

                /**
                 * Marks the instance as <b>ready</b> and runs all it's callbacks
                 *
                 * @method _ready
                 * @for Ready
                 * @private
                 */
                _ready : function() {
                    this._readyStatus = true;
                    forEach(this._callbacks, function(f) { f(); });
                }
            }
        }),

        /**
         * The Module class represents a module within the modl tree. It can
         * load other <b>modules</b>(dependencies contained within
         * <code>node_modules</code> directory) and <b>assets</b> (files
         * referenced within a module).
         *
         * @class Module
         * @extends Ready
         * @constructor
         * @private
         * @param {string} name The module's name
         * @param {string} path The module's path
         */
        Module = Ready.descend({
            constr : function(name, path) {

                merge(this, {

                    /**
                     * It's name
                     *
                     * @property _name
                     * @for Module
                     * @private
                     * @type {string}
                     */
                    _name : name,

                    /**
                     * It's path
                     *
                     * @property _path
                     * @for Module
                     * @private
                     * @type {string}
                     */
                    _path : path,

                    /**
                     * It's inner modules. This will contain the references for
                     * the children modules currently loaded for this module.
                     *
                     * @property _modules
                     * @for Module
                     * @private
                     * @type {object}
                     */
                    _modules : {},

                    /**
                     * It's assets. This will contain the references for all
                     * assets currently loaded within this module.
                     *
                     * @property _assets
                     * @for Module
                     * @private
                     * @type {object}
                     */
                    _assets : {}

                });

                Ready.call(this);
                log("module created: ", this);
                this.initialize();
            },

            proto : {

                /**
                 * Initializes the module loading its <code>/modl</code> asset
                 *
                 * @method initialize
                 * @for Module
                 */
                initialize : function() {
                    var that = this;

                    if (this._name !== "") {
                        this.asset("/modl").
                        when(function(err, asset) { that._ready(); });
                    } else {
                        this._ready();
                    }
                },

                /**
                 * Loads an asset within the module.
                 *
                 * @method asset
                 * @for Module
                 * @param {string} name The asset's name
                 * @return {Future} The future representing when the asset will
                 *         be loaded
                 */
                asset : function(name) {
                    var future = new Future(),
                        asset;

                    if (name in this._assets) {
                        log("old");
                        asset = this._assets[name];
                    } else {
                        log("new");
                        asset = new Asset(name, this._path);
                        this._assets[name] = asset;
                    }

                    asset._whenReady(function() {
                        future.fulfill(null, asset._loader._modl.exports);
                    });

                    return future;
                },

                /**
<<<<<<< HEAD
                 * Loads child module within the module <i>(yo dawn!)</i>.
=======
                 * Loads child module within the module <i>(Yo dawg! I heard you like modules...)</i>.
>>>>>>> gh-pages
                 *
                 * @method module
                 * @for Module
                 * @param {string} name The module's name
                 * @return {Future} The future representing when the module will
                 *         be loaded
                 */
                module : function(name) {
                    var future = new Future(),
                        module,
                        that = this;

                    if (name in this._modules) {
                        module = this._modules[name];
                    } else {
                        module = new Module(name, this._path + "/node_modules/" + name);
                        this._modules[name] = module;
                    }

                    current = module;

                    module._whenReady(function() {
                        current = that;
                        future.fulfill(null, module);
                    });

                    return future;
                }
            }
        }),

        /**
         * The Asset class represents an script file being loaded within a
         * module.
         *
         * @class Asset
         * @extends Ready
         * @constructor
         * @private
         * @param {string} name It's name
         * @param {string} path It's path
         */
        Asset = Ready.descend({
            constr : function(name, path) {
                merge(this, {

                    /**
                     * The asset's name
                     *
                     * @property _name
                     * @for Asset
                     * @private
                     * @type {string}
                     */
                    _name : name,

                    /**
                     * The asset's script path
                     *
                     * @property _script
                     * @for Asset
                     * @private
                     * @type {string}
                     */
                    _script : (path + "/lib" + name + ".js").replace(PATH_RE, "/")
                });

                Ready.call(this);
                log("asset created: ", this);
                this._load();
            },

            proto : {

                /**
                 * Actually fires the asset loading
                 *
                 * @method _load
                 * @for Asset
                 * @private
                 */
                _load : function() {
                    loadingAsset = this;
                    loadScript(this._script);
                }
            }
        }),

<<<<<<< HEAD
        Future = type({
            proto: {
=======
        /**
         * Represents a future promise
         *
         * @class Future
         * @constructor
         * @private
         */
        Future = type({
            constr : function() {
                merge(this, {
                    /**
                     * Holds the sent error
                     *
                     * @property _err
                     * @for Future
                     * @private
                     * @type {mixed}
                     */
                    _err : undef,

                    /**
                     * Holds the sent data
                     *
                     * @property _data
                     * @for Future
                     * @private
                     * @type {mixed}
                     */
                    _data : undef,

                    /**
                     * Indicates whether the promise has been fulfilled
                     *
                     * @property _fulfilled
                     * @for Future
                     * @private
                     * @type {boolean}
                     */
                    _fulfilled : false,


                    /**
                     * Holds the callback to be executed whenever the promise is fulfilled
                     *
                     * @property _when
                     * @for Future
                     * @private
                     * @type {function}
                     */
                    _when : undef
                });
            },
            proto: {

                /**
                 * Fulfills the promise
                 *
                 * @method fulfill
                 * @for Future
                 * @param {mixed} [err] The error to be sent
                 * @param {mixed} [data] The data to be sent
                 */
>>>>>>> gh-pages
                fulfill : function(err, data) {
                    this._err = err;
                    this._data = data;

                    if (this._fulfilled) {
                        throw new Error("Future already fulfilled");
                    }

                    this._fulfilled = true;
                    if (this._when) {
                        this._when.call(null, err, data);
                    }
                },

<<<<<<< HEAD
=======
                /**
                 * Register the callback if the promise is to be fulfilled,
                 * otherwise just runs it passing along the error/data
                 * associated with the future
                 *
                 * @method when
                 * @for Future
                 * @param {function} f The callback function
                 */
>>>>>>> gh-pages
                when : function(f) {
                    if (this._fulfilled) {
                        f(this._err, this._data);
                    } else {
                        this._when = f;
                    }
                }
            }
        }),

<<<<<<< HEAD
        Loader = Ready.descend({
            constr : function() {
                merge(this, {
                    _requires : [],
=======
        /**
         * The loader class responsible for loading the various dependencies between modules and assets
         *
         * @class Loader
         * @extends Ready
         * @constructor
         * @private
         */
        Loader = Ready.descend({
            constr : function() {
                merge(this, {
                    /**
                     * The requires collection containing the various required
                     * data
                     *
                     * @property _requires
                     * @for Loader
                     * @private
                     * @type {array}
                     */
                    _requires : [],

                    /**
                     * The modl instance to be passed along to the exports
                     * callback function when called
                     *
                     * @property _modl
                     * @for Loader
                     * @private
                     * @type {object}
                     */
>>>>>>> gh-pages
                    _modl : {
                        imports : {},
                        exports : {}
                    },
<<<<<<< HEAD
=======

                    /**
                     * The callback function to be executed when all the
                     * requires are ready
                     *
                     * @property _payload
                     * @for Loader
                     * @private
                     * @type {function}
                     */
>>>>>>> gh-pages
                    _payload : function() {}
                });

                Ready.call(this);

                log("loader created: ", this);
            },

            proto : {
<<<<<<< HEAD
=======

                /**
                 * Requires an asset from it. The <b>resource</b> string may
                 * have the following formats:
                 *
                 *  - <code>"/path/to/asset</code>: in this case the asset
                 * within the current module will be loaded
                 *
                 *  - <code>"module"</code>: in this case the "module" within
                 * <code>node_modules</code> folder will be required, and
                 * afterwards the <code>/modl</code> asset within the module
                 * will be loaded.
                 *
                 *  - <code>"module/path/to/asset"</code>: in this case the
                 * "module" within <code>node_modules</code> folder will be
                 * required, and afterwards the indicated asset within the
                 * module will be loaded.
                 *
                 * Optionally an <b>alias</b> property may be passed to name
                 * the required asset within the <b>imports</b> object. If
                 * ommited, the alias will be automatically generated based the
                 * <b>resource</b> value.
                 *
                 * @param {string} resource A given resource to be required
                 * @param {string} [alias] An optional alias which to be named
                 *              within the <b>imports</b> object.
                 * @method require
                 * @for Loader
                 * @chainable
                 * @return {Loader} The loader instance
                 */
>>>>>>> gh-pages
                require : function(resource, alias) {
                    this._requires.push({resource : resource, alias : alias});
                    return this;
                },

<<<<<<< HEAD
=======
                /**
                 * Schedules a given <b>payload</b>
                 * function export the <i>asset</i>. The <b>payload</b> will only
                 * run when all the requires are loaded and ready for prime time.
                 *
                 * When called, the <b>payload</b> function will receive the
                 * <b>module</b> struct as its first argument and as second
                 * argument, the <b>imports</b> object containing all required
                 * resources within will be passed.
                 *
                 * The <b>module</b> object will have an <code>exports</code>
                 * property which will be published for this asset. This property
                 * can be overwritten with any value this asset may want to publish (<i>a
                 * la</i> nodejs module system).
                 *
                 * The <b>module</b> object will also have an <code>imports</code>
                 * object containing all required resources which will be also
                 * passed as a second argument to the <b>payload</b> function
                 *
                 * @method exports
                 * @for Loader
                 * @param {function} payload The payload function
                 */
>>>>>>> gh-pages
                exports : function(payload) {
                    if (loadingAsset) {
                        this._attachAsset(loadingAsset);
                        loadingAsset = undef;
                    }
                    this._payload = payload;
                    this._dispatch();
                },

<<<<<<< HEAD
=======
                /**
                 * Attach a given asset to this Loader. When the loader is
                 * ready, the asset will also be market as ready
                 *
                 * @method _attachAsset
                 * @for Loader
                 * @private
                 * @param {Asset} asset The asset to be attached
                 */
>>>>>>> gh-pages
                _attachAsset : function(asset) {
                    asset._loader = this;
                    this._whenReady(function() { asset._ready(); });
                },

<<<<<<< HEAD
                _dispatch : function() {
                    var that = this;
=======
                /**
                 * Dispatches the loader processing. It will start loading all
                 * its requires and finally will run the payload function.
                 *
                 * @method _dispatch
                 * @for Loader
                 * @private
                 */
                _dispatch : function() {
                    var that = this,
                        aliases = {};

                    forEach(this._requires, function(r) {
                        r.details = parseResource(r);

                        if (hop(aliases, r.details.alias)) {
                            throw new Error("Alias clash: " + r.details.alias);
                        }

                        aliases[r.details.alias] = undef;
                    });

>>>>>>> gh-pages
                    setTimeout(function() {
                        that._loadRequires().
                        when(function() {
                            that._payload.call(null, that._modl, that._modl.imports);
                            that._ready();
                        });
                    });
                },

<<<<<<< HEAD
=======
                /**
                 * Loads all requires for the loader.
                 *
                 * @method _loadRequires
                 * @for Loader
                 * @private
                 * @return {Future} A promise for when all the requires are ready.
                 */
>>>>>>> gh-pages
                _loadRequires : function() {
                    var future = new Future(),
                        that = this,
                        requires = this._requires.slice(),

                        load = function(require) {
                            if (!require) {
                                log("done loading requires, moving on");
                                return future.fulfill();
                            }

                            that._loadRequire(require).
                            when(function() { load(requires.shift()); });
                        };

                    log("loading requires");

                    load(requires.shift());
                    return future;
                },

<<<<<<< HEAD
                _loadRequire : function(require) {
                    var
                        resource,
                        module,
                        asset,
                        future = new Future(),
                        that = this,

                        when = function(err, asset) {
                            log("require loaded: ", require);
                            that._modl.imports[resource.alias] = asset;
=======
                /**
                 * Loads a given requicre
                 *
                 * @param {object} require The require struct containing all its details
                 * @return {Future} The promise for when the require is done
                 */
                _loadRequire : function(require) {
                    var
                        details = require.details,
                        module = details.module,
                        asset = details.asset,
                        alias = details.alias,
                        future = new Future(),
                        that = this,

                        when = function(err, assetInstance) {
                            log("require loaded: ", require);
                            that._modl.imports[alias] = assetInstance;
>>>>>>> gh-pages
                            future.fulfill();
                        };

                    log("loading require: ", require);

<<<<<<< HEAD
                    resource = parseResource(require);
                    module = resource.module;
                    asset = resource.asset;

=======
>>>>>>> gh-pages
                    if (module) {
                        current.module(module).
                        when(function(err, module) {
                            module.asset(asset).
                            when(when);
                        });
                    } else {
                        current.asset(asset).
                        when(when);
                    }

                    return future;
                }
            }
        }),

        /**
         * The modl loader
         *
         * @class modl
         * @static
         */
        modl = {

            /**
             * Creates a <b>Loader</b> and requires an asset from it. The
             * <b>resource</b> string may have the following formats:
             *
             *  - <code>"/path/to/asset</code>: in this case the asset within
             * the current module will be loaded
             *
             *  - <code>"module"</code>: in this case the "module" within
             * <code>node_modules</code> folder will be required, and
             * afterwards the <code>/modl</code> asset within the module will
             * be loaded.
             *
             *  - <code>"module/path/to/asset"</code>: in this case the
             * "module" within <code>node_modules</code> folder will be
             * required, and afterwards the indicated asset within the module
             * will be loaded.
             *
             * Optionally an <b>alias</b> property may be passed to name the
             * required asset within the <b>imports</b> object. If
             * ommited, the alias will be automatically generated based the
             * <b>resource</b> value.
             *
             * @param {string} resource A given resource to be required
             * @param {string} [alias] An optional alias which to be named within the
             *            <b>imports</b> object.
             * @method require
             * @for modl
             * @static
             * @chainable
             * @return {Loader} The loader instance
             */
            require : function(resource, alias) {
                log("modl.require called, creating new loader");
                var loader = new Loader();
                return loader.require(resource, alias);
            },

            /**
             * Creates a <b>Loader</b> and schedules a given <b>payload</b>
             * function export the <i>asset</i>. The <b>payload</b> will only
             * run when all the requires are loaded and ready for prime time.
             *
             * When called, the <b>payload</b> function will receive the
             * <b>module</b> struct as its first argument and as second
             * argument, the <b>imports</b> object containing all required
             * resources within will be passed.
             *
             * The <b>module</b> object will have an <code>exports</code>
             * property which will be published for this asset. This property
             * can be overwritten with any value this asset may want to publish (<i>a
             * la</i> nodejs module system).
             *
             * The <b>module</b> object will also have an <code>imports</code>
             * object containing all required resources which will be also
             * passed as a second argument to the <b>payload</b> function
             *
             * @method exports
             * @for modl
             * @static
             * @param {function} payload The payload function
             */
            exports : function(payload) {
                log("modl.exports called, creating new loader");
                var loader = new Loader();
                loader.exports(payload);
            },

            /**
             * Sets up the modl environment. It will reset all loaded modules
             * and will set up the settings object along with the values passed
             * along with the <b>options</b> parameter.
             *
             * This function <b>MUST</b> be called before any require/exports
             * can be actually made.
             *
             * @method setup
             * @for modl
             * @static
             * @param {object} options The options parameter
             * @param {string} options.root The root directory form which to load all
             *            assets and modules
             * @param {boolean} [options.debug] If this flag is on, it will emit debug
             *            messages to a console if available
             */
            setup : function(options) {
                settings = {};
                merge(settings, options, validSettings);
                current = new Module("", settings.root);
            }
        };

    if (node) {
        module.exports = modl;
    } else {
        global.modl = modl;
    }

}(this));